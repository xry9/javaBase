2、-----------------------------
 当调用范型方法时，编译器自动对类型参数进行赋值，当不能成功赋值时报编译错误。例如
 public <T> T testGenericMethodDefine3(T t, List<T> list){
     ...
 }
 public <T> T testGenericMethodDefine4(List<T> list1, List<T> list2){
     ...
 }
 Integer i = null;
 List<Number> list1 = null;
 testGenericMethodDefine3(i, list1)//此时T为Number
 List<Integer> list2 = null;
 testGenericMethodDefine4(list1, list2)//编译报错
 4、--------------------
在上面两小节中，对是类型参数赋予具体的值，除此，还可以对类型参数赋予不确定值。例如
 List<?> unknownList;
 List<? extends Number> unknownNumberList;
 List<? super Integer> unknownBaseLineIntgerList;
 注意： 在Java集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能像其中添加元素，
 因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL

 List<String> listString;
 List<?> unknownList2 = listString;
 unknownList = unknownList2;
 listString = unknownList;//编译错误
 5、---------------------------
  可以使用带范型参数值的类声明数组，却不可有创建数组
 List<Integer>[] iListArray;
 new ArrayList<Integer>[10];//编译时错误
 6、-----------------
Java范型时编译时技术，在运行时不包含范型信息，仅仅Class的实例中包含了类型参数的定义信息。
泛型是通过java编译器的称为擦除(erasure)的前端处理来实现的。你可以（基本上就是）把它认为是一个从源码到源码的转换，它把泛型版本转换成非泛型版本。
基本上，擦除去掉了所有的泛型类型信息。所有在尖括号之间的类型信息都被扔掉了，因此，比如说一个
List<String>类型被转换为List。所有对类型变量的引用被替换成类型变量的上限(通常是Object)。而且，
无论何时结果代码类型不正确，会插入一个到合适类型的转换。
       <T> T badCast(T t, Object o) {
         return (T) o; // unchecked warning
       }
类型参数在运行时并不存在。这意味着它们不会添加任何的时间或者空间上的负担，这很好。不幸的是，这也意味
着你不能依靠他们进行类型转换。
7、-----------------------
一个泛型类被其所有调用共享
下面的代码打印的结果是什么？
       List<String> l1 = new ArrayList<String>();
       List<Integer> l2 = new ArrayList<Integer>();
       System.out.println(l1.getClass() == l2.getClass());
或许你会说false，但是你想错了。它打印出true。因为一个泛型类的所有实例在运行时具有相同的运行时类(class)，
而不管他们的实际类型参数。
事实上，泛型之所以叫泛型，就是因为它对所有其可能的类型参数，有同样的行为；同样的类可以被当作许多不同的类型。
作为一个结果，类的静态变量和方法也在所有的实例间共享。这就是为什么在静态方法或静态初始化代码
中或者在静态变量的声明和初始化时使用类型参数（类型参数是属于具体实例的）是不合法的原因。
 8、---------------------------
 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：
ArrayList<String> arrayList1=new ArrayList(); //第一种 情况  
ArrayList arrayList2=new ArrayList<String>();//第二种 情况  
不过在第一种情况，可以实现与 完全使用泛型参数一样的效果，第二种则完全没效果。
----
ArrayList<String> arrayList1=new ArrayList<String>();  
  arrayList1.add(new String());  
  arrayList1.add(new String());  
  ArrayList<Object> arrayList2=arrayList1;//编译错误  
没错，这样的情况好的多，最起码，在我们用arrayList2取值的时候不会出现ClassCastException，
因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。
我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用arrayList2
往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？
